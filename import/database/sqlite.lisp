(defpackage org.lispbuilds.nix/database/sqlite
  (:use :cl)
  (:import-from :str)
  (:import-from :sqlite)
  (:import-from :alexandria :read-file-into-string)
  (:import-from :arrow-macros :->>)
  (:import-from
   :org.lispbuilds.nix/util
   :replace-regexes)
  (:import-from
   :org.lispbuilds.nix/nix
   :nix-eval
   :system-master
   :make-pname
   :*nix-attrs-depth*)
  (:import-from
   :org.lispbuilds.nix/api
   :database->nix-expression)
  (:export :sqlite-database :init-db)
  (:local-nicknames
   (:json :com.inuoe.jzon)))

(in-package org.lispbuilds.nix/database/sqlite)

(defclass sqlite-database ()
  ((url :initarg :url
        :reader database-url
        :initform (error "url required"))
   (init-file :initarg :init-file
              :reader init-file
              :initform (error "init file required"))))

(defun init-db (db init-file)
  (let ((statements (->> (read-file-into-string init-file)
                         (replace-regexes '(".*--.*") '(""))
                         (substitute #\Space #\Newline)
                         (str:collapse-whitespaces)
                         (str:split #\;)
                         (mapcar #'str:trim)
                         (remove-if #'str:emptyp))))
    (sqlite:with-transaction db
      (dolist (s statements)
        (sqlite:execute-non-query db s)))))


;; Writing Nix

(defparameter prelude "
# This file was auto-generated by nix-quicklisp.lisp

{ pkgs, ... }:

with builtins;

# Ensures that every non-slashy `system` exists in a unique .asd file.
# (Think cl-async-base being declared in cl-async.asd upstream)
#
# This is required because we're building and loading a system called
# `system`, not `asd`, so otherwise `system` would not be loadable
# without building and loading `asd` first.
#
let createAsd = { url, sha256, asd, system }:
   let
     src = fetchTarball { inherit url sha256; };
   in pkgs.runCommand \"source\" {} ''
      mkdir -pv $out
      cp -r ${src}/* $out
      find $out -name \"${asd}.asd\" | while read f; do mv -fv $f $(dirname $f)/${system}.asd || true; done
  '';
in rec {")

(defmethod database->nix-expression ((database sqlite-database) outfile)
  (sqlite:with-open-database (db (database-url database))
    (with-open-file (f outfile
                       :direction :output
                       :if-exists :supersede)

      ;; Fix known problematic packages before dumping the nix file.
      (sqlite:execute-non-query db
       "create temp table fixed_systems as select * from system_view")

      ;; Generic-cl has a deep dependency graph which makes Nix
      ;; evaluation extremely slow and memory hungry. It takes a
      ;; minute or two and takes 4G of memory.
      ;;
      ;; The deep graph consists of generic-cl's submodules. But
      ;; nothing else depends on these, except for generic-cl
      ;; itself. This can be discovered by the query:
      ;;
      ;;   select 
      ;;     name, 
      ;;     (select name from system where id = dep.dep_id) as depname 
      ;;   from system
      ;;   join dep on dep.system_id = system.id 
      ;;   where depname like 'generic-cl.%'
      ;;   group by name
      ;;
      ;; Because of this, it's safe to just flatten the graph of
      ;; generic-cl submodules by removing them from `lispLibs`
      ;; and instead placing them in `systems`.
      ;;
      ;; All other packages are assumed to just contain one system, so
      ;; it's required to create a separate column for this new
      ;; information.
      (sqlite:execute-non-query db
       "alter table fixed_systems add column systems")

      (sqlite:execute-non-query db
       "update fixed_systems set systems = json_array(name)")

      (sqlite:execute-non-query db
       "with recursive 
        alldeps(system, subsystem, depid) as (
            select s.name, s.name, d.dep_id as depid
            from system s
            join dep d on s.id = d.system_id
            where s.name='generic-cl'
            union
            select a.system, s.name, d.dep_id as depid
            from system s, alldeps a
            join dep d on s.id = d.system_id
            where s.id = a.depid
        ),
        depids as (select distinct depid from alldeps),
        depnames as (select json_group_array(name)
                     from system where id in depids
                     and name not like 'generic-cl.%'),
        sysnames as (select json_group_array(name)
                     from system where id in depids
                     and name like 'generic-cl.%')
        update fixed_systems 
        set systems = json_insert((select * from sysnames),'$[#]',name),
            deps    = (select * from depnames)
        where name='generic-cl'")

      ;; Remove the now unneeded subsystems
      (sqlite:execute-non-query db
       "delete from fixed_systems where name like 'generic-cl.%'")

      ;; Clean up nulls.
      ;; There's probably a better way than this.
      (sqlite:execute-non-query db
       "update fixed_systems set deps = '[]' where deps = '[null]'")

      ;; The schema assumes one asd per package. This should probably
      ;; be fixed over there... but the questions is whether is even
      ;; should support multiple asds, because that quickly creates
      ;; conflicts between packages.
      ;;
      ;; For now the only reason to do this is for introspection,
      ;; i.e., so that generic-cl has it's actual asds in the
      ;; generic-cl.asds attribute.
      (sqlite:execute-non-query db
       "alter table fixed_systems add column asds")

      (sqlite:execute-non-query db
       "update fixed_systems set asds = json_array(name)")

      ;; Just so happens that every subsystem of generic-cl exists in
      ;; same-names asd file.
      (sqlite:execute-non-query db
       "update fixed_systems set asds = systems where name = 'generic-cl'")

      (format f prelude)
      (dolist (p (sqlite:execute-to-list db "select * from fixed_systems"))
        (destructuring-bind (name version asd url sha256 deps systems asds) p
          (format f "~%  ")
          (let ((*nix-attrs-depth* 1))
            (format
             f
             "~a = ~a;"
             (nix-eval `(:symbol ,name))
             (nix-eval
              `(:attrs
                ("pname" (:string ,(make-pname name)))
                ("version" (:string ,version))
                ("asds" (:list
                         ,@(mapcar (lambda (asd)
                                     `(:string ,(system-master asd)))
                                   (coerce (json:parse asds) 'list))))
                ("src" (:funcall
                        "createAsd"
                        (:attrs
                         ("url" (:string ,url))
                         ("sha256" (:string ,sha256))
                         ("system" (:string ,(system-master name)))
                         ("asd" (:string ,asd)))))
                ("systems" (:list
                            ,@(mapcar (lambda (sys)
                                        `(:string ,sys))
                                      (coerce (json:parse systems) 'list))))
                ("lispLibs" (:list
                             ,@(mapcar (lambda (dep)
                                         `(:symbol ,dep))
                                       (remove "asdf"
                                               (coerce (json:parse deps) 'list)
                                               :test #'string=))))))))))
      (format f "~%}"))))
