# TODO:
# - faster build by using lisp with preloaded asdf?
# - dont include java libs unless abcl?
# - dont use build-asdf-system to build lispWithPackages?
# - make the lisp packages overridable? (e.g. buildInputs glibc->musl)
# - build asdf with nix and use that instead of one shipped with impls
#   (e.g. to fix build with clisp - does anyone use clisp?)
# - claspPackages ? (gotta package clasp with nix first)
# - hard one: remove unrelated sources ( of systems not being built)
# - figure out a less awkward way to patch sources
#   (have to build from src directly for SLIME to work, so can't just patch sources in place)

{ pkgs
, lib
, stdenv
, abclSpec
, eclSpec
, cclSpec
, claspSpec
, clispSpec
, sbclSpec
, ... }:

let

  inherit (lib)
    length
    filter
    foldl
    unique
    id
    concat
    concatMap
    mutuallyExclusive
    findFirst
    remove
    setAttr
    getAttr
    hasAttr
    attrNames
    attrValues
    filterAttrs
    mapAttrs
    splitString
    concatStringsSep
    concatMapStringsSep
    replaceStrings
    removeSuffix
    hasInfix
    optionalString
    makeBinPath
    makeLibraryPath
    makeSearchPath
    recurseIntoAttrs
  ;

  inherit (builtins)
    head
    tail
    elem
    split
    storeDir;

  inherit (pkgs)
    substituteAll;

  # Stolen from python-packages.nix
  # Actually no idea how this works
  makeOverridableLispPackage = f: origArgs:
    let
      ff = f origArgs;
      overrideWith = newArgs: origArgs // (if pkgs.lib.isFunction newArgs then newArgs origArgs else newArgs);
    in
      if builtins.isAttrs ff then (ff // {
        overrideLispAttrs = newArgs: makeOverridableLispPackage f (overrideWith newArgs);
      })
      else if builtins.isFunction ff then {
        overrideLispAttrs = newArgs: makeOverridableLispPackage f (overrideWith newArgs);
        __functor = self: ff;
      }
      else ff;

  buildAsdf = { asdf, pkg, program, flags }:
    stdenv.mkDerivation {
      inherit (asdf) pname;
      version = "${asdf.version}-${pkg.pname}";
      dontUnpack = true;
      dontInstall = true;
      # Co z kilkoma różynmi wersjami ASDF w profilu?
      buildCommand = ''
        ${pkg}/bin/${program} ${flags} <<EOF
          (let* ((fasl (compile-file-pathname "asdf"))
                 (out (merge-pathnames #P"$out/" fasl)))
            (ensure-directories-exist #P"$out/")
            (compile-file "${asdf}" :output-file out))
        EOF
      '';
    };


  #
  # Wrapper around stdenv.mkDerivation for building ASDF systems.
  #
  build-asdf-system = makeOverridableLispPackage (
    { pname,
      version,
      src ? null,
      patches ? [],

      # Native libraries, will be appended to the library path
      nativeLibs ? [],

      # Java libraries for ABCL, will be appended to the class path
      javaLibs ? [],

      # Lisp dependencies
      # these should be packages built with `build-asdf-system`
      # TODO(kasper): use propagatedBuildInputs
      lispLibs ? [],

      # Derivation containing the CL implementation package
      pkg,

      # Name of the Lisp exectable
      program ? pkg.pname,

      # General flags to the Lisp executable
      flags ? "",

      # ASDF amalgamation file to use
      # Created in build/asdf.lisp by `make` in ASDF source tree
      asdf,

      # Some libraries have multiple systems under one project, for
      # example, cffi has cffi-grovel, cffi-toolchain etc.  By
      # default, only the `pname` system is build.
      #
      # .asd's not listed in `systems` are removed in
      # installPhase. This prevents asdf from referring to uncompiled
      # systems on run time.
      #
      # Also useful when the pname is differrent than the system name,
      # such as when using reverse domain naming.
      systems ? [ pname ],

      # The .asd files that this package provides
      # TODO(kasper): remove
      asds ? systems,

      # Files wich have a .asd suffix but should be included in the build output
      # anyway.
      extraAsds ? [],

      # Other args to mkDerivation
      ...
    } @ args:

    stdenv.mkDerivation (rec {
      inherit
        pname version nativeLibs javaLibs lispLibs systems asds
        pkg program flags
      ;

      # When src is null, we are building a lispWithPackages and only
      # want to make use of the dependency environment variables
      # generated by build-asdf-system
      dontUnpack = src == null;

      # Portable script to build the systems.
      #
      # `lisp` must evaluate this file then exit immediately. For
      # example, SBCL's --script flag does just that.
      #
      # NOTE:
      # Every other library worked fine with asdf:compile-system in
      # buildScript.
      #
      # cl-syslog, for some reason, signals that CL-SYSLOG::VALID-SD-ID-P
      # is undefined with compile-system, but works perfectly with
      # load-system. Strange.

      # TODO(kasper) portable quit
      asdfFasl = buildAsdf { inherit asdf pkg program flags; };

      buildScript = pkgs.runCommand "builder.lisp" { inherit asdfFasl; } ''
        substitute ${./builder.lisp} $out \
          --replace @asdf@ "$(find $asdfFasl -mindepth 1 -print -quit)"
      '';

      LISP = "${pkg}/bin/${program} ${flags}";

      # Build from $src so that go-to-definition works in SLIME/Sly.
      # Can it be achieved while compiling from $PWD?
      # See SBCL's :SOURCE-NAMESTRING argument to WITH-COMPILATION-UNIT.
      buildPhase = optionalString (src != null) ''
        $LISP < $buildScript
        test -f .lisp-build-done
      '';

      # Copy compiled files to store
      installPhase = ''
        # TODO this is a hack at best. Fix osicat and others using cffi-grovel
        # by setting a different output translation for shared objects
        if [ -n "$(find $out -name '*.so' -print -quit)" ]; then
          mkdir -p $out/lib
        fi
        find $out -name '*.so' -exec ln -s "{}" $out/lib \;

        ln -s $asdfFasl/* $out/share/common-lisp/asdf/*
        mkdir -pv $out/share/common-lisp/systems/
        for s in $systems; do
          ln -s $src $out/share/common-lisp/systems/$s
        done
        local sys=''${systems%% *}
        local fasl="$(find "$out/share/common-lisp/fasl/" -mindepth 1 -maxdepth 1 -type d -print -quit)"
        systems="$systems "
        for s in ''${systems#* }; do
          ln -s $fasl/$sys $fasl/$s
        done
      '';

      dontPatchShebangs = true;

      # Not sure if it's needed, but caused problems with SBCL
      # save-lisp-and-die binaries in the past
      dontStrip = true;

      setupHook = ./setup-hook.sh;

    } // (args // rec {
      src = pkgs.applyPatches {
        inherit (args) src;
        systems = args.systems or [ args.pname ];
        patches = args.patches or [];
        postPatch = ''
          declare -A asds
          for s in $systems; do
            local asd="\"$(find -name ''${s%%/*}.asd -type f -print -quit)\""
            asds["$asd"]=1
          done
          echo "(:source-registry-cache ''${!asds[@]})" > .cl-source-registry.cache
        '' + args.postPatch or "";
      };
      patches = [];
      postPatch = "";
      propagatedBuildInputs = args.propagatedBuildInputs or []
          ++ lispLibs ++ javaLibs ++ nativeLibs;          
      propagatedUserEnvPkgs = propagatedBuildInputs;
    })));

  # Build the set of lisp packages using `lisp`
  # These packages are defined manually for one reason or another:
  # - The library is not in quicklisp
  # - The library that is in quicklisp is broken
  # - Special build procedure such as cl-unicode, asdf
  #
  # They can use the auto-imported quicklisp packages as dependencies,
  # but some of those don't work out of the box.
  #
  # E.g if a QL package depends on cl-unicode it won't build out of
  # the box.
  commonLispPackagesFor = spec:
    let
      build-asdf-system' = body: build-asdf-system (body // spec);
    in pkgs.callPackage ./packages.nix {
      inherit spec quicklispPackagesFor;
      build-asdf-system = build-asdf-system';
    };

  # Build the set of packages imported from quicklisp using `lisp`
  quicklispPackagesFor = spec:
    let
      build-asdf-system' = body: build-asdf-system (body // spec);
    in pkgs.callPackage ./ql.nix {
      build-asdf-system = build-asdf-system';
    };

  # Creates a lisp wrapper with `packages` installed
  #
  # `packages` is a function that takes `clpkgs` - a set of lisp
  # packages - as argument and returns the list of packages to be
  # installed
  # TODO(kasper): assert each package has the same lisp and asdf?
  lispWithPackagesInternal = spec: clpkgs: packages:
    let
      lisp = spec.pkg;
      env = pkgs.buildEnv {
        name = "${lisp.pname}-env";
        paths = packages clpkgs;
      };
    in stdenv.mkDerivation {
      inherit (lisp) pname;
      version = "${lisp.version}+packages";
      nativeBuildInputs = [ pkgs.makeBinaryWrapper ];
      buildCommand = ''
        mkdir -pv $out/bin
        local systems="$(echo ${env}/share/common-lisp/systems/)"
        local asdf="$(echo ${env}/share/common-lisp/asdf/*/*)"
        local fasl="$(find ${env}/share/common-lisp/fasl/ -mindepth 1 -maxdepth 1 -type d -print -quit)/"
        local jars="$(find ${env}/share/java/ -name '*.jar' -print0 | tr '\0' ':')"
        makeWrapper \
          ${lisp}/bin/${spec.program} \
          $out/bin/${spec.program} \
          --add-flags "${spec.flags}" \
          --set ASDF "$asdf" \
          --prefix CL_SOURCE_REGISTRY : "$systems/" \
          --prefix ASDF_OUTPUT_TRANSLATIONS : "$systems:$fasl" \
          --prefix LD_LIBRARY_PATH : ${env}/lib \
          --prefix DYLD_LIBRARY_PATH : ${env}/lib \
          --prefix CLASSPATH : "$jars" \
          --prefix PATH : ${env}/bin
      '';
    };

  makeLisp = lib.makeOverridable ({ packageOverlays ? (self: super: {}), spec }:
    let
      pkgs = (commonLispPackagesFor spec).overrideScope' packageOverlays;
    in spec.pkg // {
      inherit pkgs;
      inherit (spec) asdf;
      withPackages = lispWithPackagesInternal spec pkgs;
      buildASDFSystem = args: build-asdf-system (args // spec);
    });
  
  lisps = {
    sbcl = makeLisp { spec = sbclSpec; };
    ecl = makeLisp { spec = eclSpec; };
    abcl = makeLisp { spec = abclSpec; };
    clisp = makeLisp { spec = clispSpec; };
    clasp = makeLisp { spec = claspSpec; };
    ccl = makeLisp { spec = cclSpec; };
  };

in lisps
