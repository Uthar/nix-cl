# TODO:
# - faster build by using lisp with preloaded asdf?
# - dont include java libs unless abcl?
# - dont use build-asdf-system to build lispWithPackages?
# - make the lisp packages overridable? (e.g. buildInputs glibc->musl)
# - build asdf with nix and use that instead of one shipped with impls
#   (e.g. to fix build with clisp - does anyone use clisp?)
# - claspPackages ? (gotta package clasp with nix first)
# - hard one: remove unrelated sources ( of systems not being built)
# - figure out a less awkward way to patch sources
#   (have to build from src directly for SLIME to work, so can't just patch sources in place)

{ pkgs
, lib
, stdenv
, abclArgs
, eclArgs
, cclArgs
, claspArgs
, clispArgs
, sbclArgs
, defaultAsdf
, ... }:

let

  inherit (lib)
    length
    filter
    foldl
    unique
    id
    concat
    concatMap
    mutuallyExclusive
    findFirst
    remove
    setAttr
    getAttr
    hasAttr
    attrNames
    attrValues
    filterAttrs
    mapAttrs
    splitString
    concatStringsSep
    concatMapStringsSep
    replaceStrings
    removeSuffix
    hasInfix
    optionalString
    makeLibraryPath
    makeSearchPath
    recurseIntoAttrs
  ;

  inherit (builtins)
    head
    tail
    elem
    split
    storeDir;

  inherit (pkgs)
    substituteAll;

  asdfHook = import ./setup-hook.nix;

  # Stolen from python-packages.nix
  # Actually no idea how this works
  makeOverridableLispPackage = f: origArgs:
    let
      ff = f origArgs;
      overrideWith = newArgs: origArgs // (if pkgs.lib.isFunction newArgs then newArgs origArgs else newArgs);
    in
      if builtins.isAttrs ff then (ff // {
        overrideLispAttrs = newArgs: makeOverridableLispPackage f (overrideWith newArgs);
      })
      else if builtins.isFunction ff then {
        overrideLispAttrs = newArgs: makeOverridableLispPackage f (overrideWith newArgs);
        __functor = self: ff;
      }
      else ff;

  buildAsdf = { asdf, pkg, program, flags, evalFlags, faslExt }:
    stdenv.mkDerivation {
      inherit (asdf) pname version;
      dontUnpack = true;
      buildPhase = ''
        cp -v ${asdf} asdf.lisp
        ${pkg}/bin/${program} \
          ${flags} \
          ${evalFlags} '(compile-file "asdf.lisp")' \
          ${evalFlags} '(quit)'
      '';
      installPhase = ''
        mkdir -p $out
        cp -v asdf.${faslExt} $out
      '';
    };


  #
  # Wrapper around stdenv.mkDerivation for building ASDF systems.
  #
  build-asdf-system = makeOverridableLispPackage (
    { pname,
      version,
      src ? null,
      patches ? [],

      # Native libraries, will be appended to the library path
      nativeLibs ? [],

      # Java libraries for ABCL, will be appended to the class path
      javaLibs ? [],

      # Lisp dependencies
      # these should be packages built with `build-asdf-system`
      lispLibs ? [],

      # Lisp implementation parameters
      pkg,
      program ? pkg.pname,
      flags ? "",
      faslExt,

      # FIXME(kasper): get rid of these two, use stdin
      loadFlags ? "--load",
      evalFlags ? "--eval",
      
      # ASDF amalgamation file to use
      asdf ? defaultAsdf,

      # Some libraries have multiple systems under one project, for
      # example, cffi has cffi-grovel, cffi-toolchain etc.  By
      # default, only the `pname` system is build.
      #
      # .asd's not listed in `systems` are removed in
      # installPhase. This prevents asdf from referring to uncompiled
      # systems on run time.
      #
      # Also useful when the pname is differrent than the system name,
      # such as when using reverse domain naming.
      systems ? [ pname ],

      # The .asd files that this package provides
      asds ? systems,

      # Other args to mkDerivation
      ...
    } @ args:
    
    stdenv.mkDerivation (rec {
      inherit
        pname version nativeLibs javaLibs lispLibs systems asds
        pkg program flags loadFlags faslExt evalFlags
      ;

      buildInputs = [ asdfHook];
      propagatedBuildInputs = lispLibs ++ nativeLibs ++ javaLibs;

      src = if builtins.length patches > 0
            then apply-patches args
            else args.src;

      # When src is null, we are building a lispWithPackages and only
      # want to make use of the dependency environment variables
      # generated by build-asdf-system
      dontUnpack = src == null;

      # Portable script to build the systems.
      #
      # `lisp` must evaluate this file then exit immediately. For
      # example, SBCL's --script flag does just that.
      #
      # NOTE:
      # Every other library worked fine with asdf:compile-system in
      # buildScript.
      #
      # cl-syslog, for some reason, signals that CL-SYSLOG::VALID-SD-ID-P
      # is undefined with compile-system, but works perfectly with
      # load-system. Strange.

      # TODO(kasper) portable quit
      asdfFasl = buildAsdf { inherit asdf pkg program flags evalFlags faslExt; };
      
      buildScript = substituteAll {
        src = ./builder.lisp;
        asdf = "${asdfFasl}/asdf.${faslExt}";
      };

      preConfigure = ''
        source ${./setup-hook.sh}
        buildAsdfPath
      '';

      buildPhase = optionalString (src != null) ''
        export CL_SOURCE_REGISTRY=$CL_SOURCE_REGISTRY:$src//                  
        export ASDF_OUTPUT_TRANSLATIONS="$src:$(pwd):${storeDir}:${storeDir}" 
        ${pkg}/bin/${program} ${flags} ${loadFlags} $buildScript
      '';

      # Copy compiled files to store
      #
      # Make sure to include '$' in regex to prevent skipping
      # stuff like 'iolib.asdf.asd' for system 'iolib.asd'
      #
      # Same with '/': `local-time.asd` for system `cl-postgres+local-time.asd`
      installPhase =
        let
          mkSystemsRegex = systems:
            concatMapStringsSep "\\|" (replaceStrings ["." "+"] ["[.]" "[+]"]) systems;
        in
      ''
        mkdir -pv $out
        cp -r * $out

        # Remove all .asd files except for those in `systems`.
        find $out -name "*.asd" \
        | grep -v "/\(${mkSystemsRegex systems}\)\.asd$" \
        | xargs rm -fv || true
      '';

      dontPatchShebangs = true;
      
      # Not sure if it's needed, but caused problems with SBCL
      # save-lisp-and-die binaries in the past
      dontStrip = true;

    } // args));

  # Need to do that because we always want to compile straight from
  # `src` for go-to-definition to work in SLIME.
  apply-patches = { patches, src, ... }:
    stdenv.mkDerivation {
      inherit patches src;
      pname = "source";
      version = "patched";
      dontConfigure = true;
      dontBuild = true;
      dontStrip = true;
      dontFixup = true;
      installPhase = ''
        mkdir -pv $out
        cp -r * $out
      '';
    };

  # Build the set of lisp packages using `lisp`
  # These packages are defined manually for one reason or another:
  # - The library is not in quicklisp
  # - The library that is in quicklisp is broken
  # - Special build procedure such as cl-unicode, asdf
  #
  # These Probably could be done even in ql.nix
  # - Want to pin a specific commit
  # - Want to apply custom patches
  #
  # They can use the auto-imported quicklisp packages as dependencies,
  # but some of those don't work out of the box.
  #
  # E.g if a QL package depends on cl-unicode it won't build out of
  # the box. The dependency has to be rewritten using the manually
  # fixed cl-unicode.
  #
  # This is done by generating a 'fixed' set of Quicklisp packages by
  # calling quicklispPackagesFor with the right `fixup`.
  commonLispPackagesFor = { pkg, program, flags ? "", loadFlags, evalFlags, faslExt, asdf ? defaultAsdf }:
    let
      build-asdf-system' = body: build-asdf-system (body // {
        inherit pkg program flags loadFlags evalFlags faslExt asdf;
      });
    in import ./packages.nix {
      inherit pkgs;
      inherit pkg program flags loadFlags evalFlags faslExt;
      inherit quicklispPackagesFor;
      inherit fixupFor;
      inherit asdf;
      build-asdf-system = build-asdf-system';
    };

  # Build the set of packages imported from quicklisp using `lisp`
  quicklispPackagesFor = { pkg, program, flags ? "", loadFlags, evalFlags,
                           faslExt, fixup ? lib.id, build ? build-asdf-system }:
    let
      build-asdf-system' = body: build (body // {
        inherit pkg program flags loadFlags evalFlags faslExt;
      });
    in pkgs.callPackage ./ql.nix {
      inherit fixup;
      build-asdf-system = build-asdf-system';
    };

  # Rewrite deps of pkg to use manually defined packages
  #
  # The purpose of manual packages is to customize one package, but
  # then it has to be propagated everywhere for it to make sense and
  # have consistency in the package tree.
  fixupFor = manualPackages: qlPkg:
    assert (lib.isAttrs qlPkg && !lib.isDerivation qlPkg);
    let
      # Make it possible to reuse generated attrs without recursing into oblivion
      packages = (lib.filterAttrs (n: v: n != qlPkg.pname) manualPackages);
      substituteLib = pkg:
        if lib.hasAttr pkg.pname packages
        then packages.${pkg.pname}
        else pkg;
      pkg = substituteLib qlPkg;
    in pkg // { lispLibs = map substituteLib pkg.lispLibs; };

  makeAttrName = str:
    removeSuffix
      "_"
      (replaceStrings
        ["+" "." "/"]
        ["_plus_" "_dot_" "_slash_"]
        str);

  # Creates a lisp wrapper with `packages` installed
  #
  # `packages` is a function that takes `clpkgs` - a set of lisp
  # packages - as argument and returns the list of packages to be
  # installed
  lispWithPackagesInternal = clpkgs: packages:
    # FIXME just use flattenedDeps instead
    (build-asdf-system rec {
      # TODO(kasper): assert each package has the same lisp and asdf?
      pkg = (head (lib.attrValues clpkgs)).pkg;
      program = (head (lib.attrValues clpkgs)).program;
      lispFlags = (head (lib.attrValues clpkgs)).lispFlags or "";
      evalFlags = (head (lib.attrValues clpkgs)).evalFlags;
      loadFlags = (head (lib.attrValues clpkgs)).loadFlags;
      faslExt = (head (lib.attrValues clpkgs)).faslExt;
      asdf = (head (lib.attrValues clpkgs)).asdf or defaultAsdf;
      # See dontUnpack in build-asdf-system
      src = null;
      pname = pkg.pname;
      version = "with-packages";
      lispLibs = packages clpkgs;
      systems = [];
    }).overrideAttrs(o: {
      nativeBuildInputs = [ pkgs.makeBinaryWrapper ];
      installPhase = ''
        echo "GI_TYPELIB_PATH: $GI_TYPELIB_PATH"
        mkdir -pv $out/bin
        makeWrapper \
          ${o.pkg}/bin/${o.program} \
          $out/bin/${o.program} \
          --add-flags "${o.flags} ${o.loadFlags} ${o.asdfFasl}/asdf.${o.faslExt}" \
          --prefix CL_SOURCE_REGISTRY : "$CL_SOURCE_REGISTRY" \
          --prefix ASDF_OUTPUT_TRANSLATIONS : "$(echo $CL_SOURCE_REGISTRY | sed s,//:,::,g):" \
          --prefix LD_LIBRARY_PATH : "$LD_LIBRARY_PATH" \
          --prefix DYLD_LIBRARY_PATH : "$DYLD_LIBRARY_PATH" \
          --prefix CLASSPATH : "$CLASSPATH" \
          --prefix GI_TYPELIB_PATH : "$GI_TYPELIB_PATH" \
      '';
    });

  lispWithPackages = { pkg, flags ? "", program ? pkg.pname, evalFlags ? "--eval",
                       loadFlags ? "--load", faslExt ? "fasl", asdf ? defaultAsdf }:
    let
      packages = lispPackagesFor {
        inherit pkg program flags loadFlags evalFlags faslExt asdf;
      };
    in lispWithPackagesInternal packages;

  lispPackagesFor = { pkg, flags ? "", program ? pkg.pname, evalFlags ? "--eval",
                      loadFlags ? "--load", faslExt ? "fasl", asdf ? defaultAsdf }:
    let
      packages = commonLispPackagesFor {
        inherit pkg program flags loadFlags evalFlags faslExt;
        inherit asdf;
      };
      qlPackages = quicklispPackagesFor {
        inherit pkg program flags loadFlags evalFlags faslExt;
        fixup = fixupFor packages;
      };
    in qlPackages // packages;

  commonLispPackages = rec {
    inherit
      build-asdf-system
      lispWithPackagesInternal
      lispPackagesFor
      lispWithPackages;

    # Manually defined packages shadow the ones imported from quicklisp

    sbclPackages  = recurseIntoAttrs (lispPackagesFor sbclArgs);
    eclPackages   = lispPackagesFor eclArgs;
    abclPackages  = lispPackagesFor abclArgs;
    cclPackages   = lispPackagesFor cclArgs;
    clispPackages = lispPackagesFor clispArgs;
    claspPackages = lispPackagesFor claspArgs;

    sbclWithPackages = lispWithPackages sbclArgs;
    eclWithPackages = lispWithPackages eclArgs;
    abclWithPackages = lispWithPackages abclArgs;
    cclWithPackages  = lispWithPackages cclArgs;
    clispWithPackages = lispWithPackages clispArgs;
    claspWithPackages = lispWithPackages claspArgs;

  };

  makeLisp = lisp:
    lisp // { withPackages = lispWithPackages lisp; };

in commonLispPackages



