# TODO:
# - faster build by using lisp with preloaded asdf?
# - dont include java libs unless abcl?
# - dont use build-asdf-system to build lispWithPackages?
# - make the lisp packages overridable? (e.g. buildInputs glibc->musl)
# - build asdf with nix and use that instead of one shipped with impls
#   (e.g. to fix build with clisp - does anyone use clisp?)
# - claspPackages ? (gotta package clasp with nix first)
# - hard one: remove unrelated sources ( of systems not being built)
# - figure out a less awkward way to patch sources
#   (have to build from src directly for SLIME to work, so can't just patch sources in place)

{ pkgs, lib, stdenv, ... }:


let

  inherit (lib)
    length
    filter
    foldl
    unique
    id
    concat
    concatMap
    mutuallyExclusive
    findFirst
    setAttr
    getAttr
    hasAttr
    attrNames
    attrValues
    filterAttrs
    mapAttrs
    splitString
    concatStringsSep
    concatMapStringsSep
    replaceStrings
    removeSuffix
    hasInfix
    optionalString
    makeLibraryPath
    makeSearchPath
  ;

  inherit (builtins)
    head
    tail
    elem
    split
    storeDir;

  frequencies = xs:
    let
      getFreq = x: freqs:
        if hasAttr x freqs
        then getAttr x freqs
        else 0;
      lp = xs: freqs:
        if builtins.length xs == 0
        then freqs
        else
          let
            x = toString (head xs);
          in lp (tail xs) (setAttr freqs x (1 + (getFreq x freqs)));
    in lp xs {};

  # Return a modified dependency tree, where each lispLibs is the
  # result of applying f to it
  editTree = lispLibs: f:
    let
      editLib = lib:
        if length lib.lispLibs == 0
        then lib
        else lib.overrideLispAttrs(o: {
          lispLibs = map editLib (f o.lispLibs);
        });
      tmpPkg = build-asdf-system {
        pname = "__editTree";
        version = "__editTree";
        lisp = "__editTree";
        src = null;
        systems = [];
        inherit lispLibs;
      };
      fixed = editLib tmpPkg;
    in fixed.lispLibs;

  # Returns a flattened dependency tree without duplicates
  flattenedDeps = lispLibs:
    let
      walk = acc: node:
        if length node.lispLibs == 0
        then acc
        else foldl walk (acc ++ node.lispLibs) node.lispLibs;
    in unique (walk [] { inherit lispLibs; });

  # Stolen from python-packages.nix
  # Actually no idea how this works
  makeOverridableLispPackage = f: origArgs:
    let
      ff = f origArgs;
      overrideWith = newArgs: origArgs // (if pkgs.lib.isFunction newArgs then newArgs origArgs else newArgs);
    in
      if builtins.isAttrs ff then (ff // {
        overrideLispAttrs = newArgs: makeOverridableLispPackage f (overrideWith newArgs);
      })
      else if builtins.isFunction ff then {
        overrideLispAttrs = newArgs: makeOverridableLispPackage f (overrideWith newArgs);
        __functor = self: ff;
      }
      else ff;

  #
  # Wrapper around stdenv.mkDerivation for building ASDF systems.
  #
  build-asdf-system = makeOverridableLispPackage (
    { pname,
      version,
      src ? null,
      patches ? [],

      # Native libraries, will be appended to the library path
      nativeLibs ? [],

      # Java libraries for ABCL, will be appended to the class path
      javaLibs ? [],

      # Lisp dependencies
      # these should be packages built with `build-asdf-system`
      lispLibs ? [],

      # Lisp command to run buildScript
      lisp,

      # Some libraries have multiple systems under one project, for
      # example, cffi has cffi-grovel, cffi-toolchain etc.  By
      # default, only the `pname` system is build.
      #
      # .asd's not listed in `systems` are removed in
      # installPhase. This prevents asdf from referring to uncompiled
      # systems on run time.
      #
      # Also useful when the pname is differrent than the system name,
      # such as when using reverse domain naming.
      systems ? [ pname ],

      # The .asd files that this package provides
      asds ? systems,

      # Other args to mkDerivation
      ...
    } @ args:

    stdenv.mkDerivation (rec {
      inherit pname version nativeLibs javaLibs lispLibs lisp systems asds;

      src = if builtins.length patches > 0
            then apply-patches args
            else args.src;

      # When src is null, we are building a lispWithPackages and only
      # want to make use of the dependency environment variables
      # generated by build-asdf-system
      dontUnpack = src == null;

      # Tell asdf where to find system definitions of lisp dependencies.
      #
      # The "//" ending is important as it makes asdf recurse into
      # subdirectories when searching for .asd's. This is to support
      # projects where .asd's aren't in the root directory.
      CL_SOURCE_REGISTRY = makeSearchPath "/" (flattenedDeps lispLibs);

      # Tell lisp where to find native dependencies
      #
      # Normally generated from lispLibs, but LD_LIBRARY_PATH as a
      # derivation attr itself can be used as an extension point when
      # the libs are not in a '/lib' subdirectory
      LD_LIBRARY_PATH =
        let
          deps = flattenedDeps lispLibs;
          libs = concatMap (x: x.nativeLibs) deps;
          paths = filter (x: x != "") (map (x: x.LD_LIBRARY_PATH) deps);
          path =
            makeLibraryPath libs
            + optionalString (length paths != 0) ":"
            + concatStringsSep ":" paths;
        in concatStringsSep ":" (unique (splitString ":" path));

      # Java libraries For ABCL
      CLASSPATH = makeSearchPath "share/java/*" (concatMap (x: x.javaLibs) (flattenedDeps lispLibs));

      # Portable script to build the systems.
      #
      # `lisp` must evaluate this file then exit immediately. For
      # example, SBCL's --script flag does just that.
      #
      # NOTE:
      # Every other library worked fine with asdf:compile-system in
      # buildScript.
      #
      # cl-syslog, for some reason, signals that CL-SYSLOG::VALID-SD-ID-P
      # is undefined with compile-system, but works perfectly with
      # load-system. Strange.
      buildScript = pkgs.writeText "build-${pname}.lisp" ''
        (require :asdf)
        (dolist (s '(${concatStringsSep " " systems}))
          (asdf:load-system s))
      '';

      buildPhase = optionalString (src != null) ''
        # In addition to lisp dependencies, make asdf see the .asd's
        # of the systems being built
        #
        # *Append* src since `lispLibs` can provide .asd's that are
        # also in `src` but are not in `systems` (that is, the .asd's
        # that will be deleted in installPhase). We don't want to
        # rebuild them, but to load them from lispLibs.
        #
        # NOTE: It's important to read files from `src` instead of
        # from pwd to get go-to-definition working with SLIME
        export CL_SOURCE_REGISTRY=$CL_SOURCE_REGISTRY:${src}//

        # Similiarily for native deps
        export LD_LIBRARY_PATH=${makeLibraryPath nativeLibs}:$LD_LIBRARY_PATH
        export CLASSPATH=${makeSearchPath "share/java/*" javaLibs}:$CLASSPATH

        # Make asdf compile from `src` to pwd and load `lispLibs`
        # from storeDir. Otherwise it could try to recompile lisp deps.
        export ASDF_OUTPUT_TRANSLATIONS="${src}:$(pwd):${storeDir}:${storeDir}"

        # Finally, compile the systems
        ${lisp} $buildScript
      '';

      # Copy compiled files to store
      #
      # Make sure to include '$' in regex to prevent skipping
      # stuff like 'iolib.asdf.asd' for system 'iolib.asd'
      #
      # Same with '/': `local-time.asd` for system `cl-postgres+local-time.asd`
      installPhase =
        let
          mkSystemsRegex = systems:
            concatMapStringsSep "\\|" (replaceStrings ["." "+"] ["[.]" "[+]"]) systems;
        in
      ''
        mkdir -pv $out
        cp -r * $out

        # Remove all .asd files except for those in `systems`.
        find $out -name "*.asd" \
        | grep -v "/\(${mkSystemsRegex systems}\)\.asd$" \
        | xargs rm -fv || true
      '';

      # Not sure if it's needed, but caused problems with SBCL
      # save-lisp-and-die binaries in the past
      dontStrip = true;
      dontFixup = true;

    } // args));

  # Need to do that because we always want to compile straight from
  # `src` for go-to-definition to work in SLIME.
  apply-patches = { patches, src, ... }:
    stdenv.mkDerivation {
      inherit patches src;
      pname = "source";
      version = "patched";
      dontConfigure = true;
      dontBuild = true;
      dontStrip = true;
      dontFixup = true;
      installPhase = ''
        mkdir -pv $out
        cp -r * $out
      '';
    };

  # Build the set of lisp packages using `lisp`
  # These packages are defined manually for one reason or another:
  # - The library is not in quicklisp
  # - The library that is in quicklisp is broken
  # - Special build procedure such as cl-unicode, asdf
  #
  # These Probably could be done even in ql.nix
  # - Want to pin a specific commit
  # - Want to apply custom patches
  #
  # They can use the auto-imported quicklisp packages as dependencies,
  # but some of those don't work out of the box.
  #
  # E.g if a QL package depends on cl-unicode it won't build out of
  # the box. The dependency has to be rewritten using the manually
  # fixed cl-unicode.
  #
  # This is done by generating a 'fixed' set of Quicklisp packages by
  # calling quicklispPackagesFor with the right `fixup`.
  commonLispPackagesFor = lisp:
    let
      build-asdf-system' = body: build-asdf-system (body // { inherit lisp; });
    in import ./packages.nix {
      inherit pkgs;
      inherit lisp;
      inherit quicklispPackagesFor;
      inherit fixupFor;
      inherit fixDuplicateAsds;
      build-asdf-system = build-asdf-system';
    };

  # Build the set of packages imported from quicklisp using `lisp`
  quicklispPackagesFor = { lisp, fixup ? lib.id, build ? build-asdf-system }:
    let
      build-asdf-system' = body: build (body // {
        inherit lisp;
      });
    in import ./ql.nix {
      inherit pkgs;
      inherit flattenedDeps;
      inherit fixup;
      build-asdf-system = build-asdf-system';
    };

  # Rewrite deps of pkg to use manually defined packages
  #
  # The purpose of manual packages is to customize one package, but
  # then it has to be propagated everywhere for it to make sense and
  # have consistency in the package tree.
  fixupFor = manualPackages: qlPkg:
    assert (lib.isAttrs qlPkg && !lib.isDerivation qlPkg);
    let
      # Make it possible to reuse generated attrs without recursing into oblivion
      packages = (lib.filterAttrs (n: v: n != qlPkg.pname) manualPackages);
      substituteLib = pkg:
        if lib.hasAttr pkg.pname packages
        then packages.${pkg.pname}
        else pkg;
      pkg = substituteLib qlPkg;
    in pkg // { lispLibs = map substituteLib pkg.lispLibs; };

  makeAttrName = str:
    removeSuffix
      "_"
      (replaceStrings
        ["+" "." "/"]
        ["_plus_" "_dot_" "_slash_"]
        str);

  # Just random notes to help reason about this function. The numbers do not
  # mean anything.
  #
  # All of this would not be needed if each ASDF system existed in its own,
  # unique .asd file.
  #
  # The biggest problem are slashy systems, because they can't be fixed like
  # other, separate systems that just happen to exist in the same .asd
  # file. There we can just create the missing asd file (or rename the original
  # one). This way ASDF will look for its system definition in the renamed file,
  # and look for the other system definition in the original file. So there is
  # no conflict now.
  #
  # ASDF itself warns about such things. Example:
  #
  # WARNING: System definition file #P"/nix/store/.../cl-ppcre-unicode.asd"
  # contains definition for system "cl-ppcre-unicode-test".
  #
  # Please only define "cl-ppcre-unicode" and secondary systems with a name
  # starting with "cl-ppcre-unicode/" (e.g. "cl-ppcre-unicode/test") in that file.
  #
  # Well, they got the first part right...
  #
  # (Side note: Originally I also thought that ASDF caches somehow system
  # definitions from files already parsed. So it would be possible that it reads
  # 'my-system.asd' while loading 'my-system', remembers that 'my-system.asd'
  # contained a definition for 'my-system-test', then it would try to compile
  # the system there instead of another file on the source registry
  # 'my-system-test.ads' (which was created as described in the previous
  # paragraph). But, I didn't find that this is happening, and I assumed it
  # doesn't. It seems like it goes and looks for an actual '<system-name>.asd'
  # file each time '<system-name>' is requested to be loaded.)
  #
  # But, slashy systems *must* exist in the same .asd file as their parent
  # system. So if we want to prevent ASDF trying to compile code into Nix store
  # (which is the reason why such weird asd file renaming has to happen in the
  # first place), we have to do something different.
  #
  # On the 'compiling into Nix store' thing. Imagine that you create a
  # 'lispWithPackages' and put 'my-system' and 'my-system-test' into its source
  # registry (CL_SOURCE_REGISTRY). Both exist in two separate 'my-system.asd'
  # files. The Nix store directory tree of 'my-system' contains FASL's of it,
  # and same for 'my-system-test'. You can load 'my-system' just fine, but when
  # trying to load 'my-system-test', it will fail because it will first find the
  # system definition in my-system's 'my-system.asd', will see that there are no
  # FASL's, and therefore try to compile them into Nix store (because
  # ASDF_OUTPUT_TRANSLATIONS is set like that, so that FASLs are actually loaded
  # from the nix store and not recompiled by the user. That's kind of the point
  # of packaging ASDF systems with Nix.)
  #
  # (Perhaps if it was possible to somehow override ASDF behavior, and make it
  # load particular systems from particular files instead of relying on the
  # 'system' -> 'system.asd' convention...)
  #
  # The reverse situation is probably also possible, where 'my-system-test' is
  # before 'my-system' on the source registry path, and so you will be able to
  # load 'my-system-test', but will get that same error for 'my-system' (it's an
  # attempt to write to a read only path, in the Nix store).
  #
  # Makes you wonder if it's even worth it to use Nix for this, rather than just
  # using Quicklisp... but maybe it is, because you can precompile reproducible
  # FASL closures, can have your own binary cache, etc...
  #
  # More notes are on the algorithm to try to work around this problem.
  #
  # (BTW, the Quicklisp imported packages (imported.nix) already handle the
  # simplest case of conflicts. Check out the 'createAsd' function there.)
  #
  # Fixing duplicate asd conflicts:
  #
  # 1. Detect if there would be multiple same-named asd files in the source
  # registry.
  #
  # 2. Figure out which packages are the conflicting ones. These will be the
  # ones that provide the same asd.
  #
  # 3. Assumes that a system named like the asd exists. Not sure what happens if
  # multiple such systems exist. (Shouldn't happen? It's an attrset so keys are
  # unique?)
  #
  # 4. If not circular, simply merge the lisp dependencies and the system names
  # of all conflicting systems (systems that provide the same asd), and use that
  # in the derivation instead. Do that for the 'asds' attr too (it says which
  # asds the resulting derivation will provide), but watch out not to include
  # slashy system names there. (Slashy systems instead exist in the asd file
  # made from the part of the system name before the slash.).
  #
  # 'lisp libs' are needed to generate the source registry path on compile time
  # to be used on run time
  #
  # 'systems' are needed to know which ones to actually compile
  #
  # 'asds' are needed to know which asd files to remove on install time (to
  # prevent trying to compile a system that was found in the nix store because
  # an asd file existed, but it's fasls didn't, because it wasn't compiled). Its
  # also used to detect circular and duplicate deps.
  #
  # Fixing circular dependencies:
  #
  # Circular dependencies are kind of different than just duplicates, in that
  # they actually overflow the Nix evaluator's stack as well.
  #
  # 1. This happens only between the packages that have already been detected as
  # being duplicates in the source registry path.
  #
  # 2. Figure out which of those packages are circular between each other. To do
  # that filter out (from the reduced dependency graph of duplicate asds)
  # packages that *still* have a duplicate somewhere in the graph. (Does this
  # even make sense? Can't it just call the duplicate fixing algorithm twice?)
  # (Or, perhaps, skip the duplicate checking completely and only run the
  # circular fix algorithm?)
  #
  # 3. Remove every package that provides the circular asd from the whole graph
  # of lispLibs.
  #
  # 4. Instead, merge the 'systems' and 'asds' of the circular systems, so that
  # they are compiled together as a single package.
  #
  # Then, after both duplicate and circular packages are "fixed", go through
  # each thing in the original lispLibs, and replace that with the "fixed"
  # version. The fixed version is found by looking for something that provides
  # the same asd. But since a package can have multiple asds, no idea what
  # happens when this occurs. Maybe it's fine, becase one asd is enough to
  # warrant a "fix" becase it's enough to cause a conflict... But what if it
  # first finds the wrong override, when there were multiple overrides?
  #
  fixDuplicateAsds = libs: clpkgs:
    let
      libsFlat = flattenedDeps libs;
      asdCounts = frequencies (concatMap (getAttr "asds") libsFlat);
      duplicates = attrNames (filterAttrs (n: v: v > 1) asdCounts);
      combineSlashySubsystems = asd:
        let
          providers = filter (lib: elem asd lib.asds) libsFlat;
          lispLibs = unique (concatMap (lib: lib.lispLibs) providers);
          systems = unique (concatMap (lib: lib.systems) providers);
          master = clpkgs.${makeAttrName asd};
          circular =
            filter
              (lib: elem asd (concatMap (getAttr "asds") lib.lispLibs))
              (flattenedDeps lispLibs);
          circularAsds = concatMap (getAttr "asds") circular;
          circularSystems = concatMap (getAttr "systems") circular;
          circularLibs = concatMap (getAttr "lispLibs") circular;
        in
          if length circular > 0
          then master.overrideLispAttrs (o: {
            lispLibs =
              editTree
                (unique (lispLibs ++ circularLibs))
                (filter
                  (lib:
                    mutuallyExclusive lib.asds (master.asds ++ circularAsds)));
            systems = systems ++ circularSystems;
            asds = master.asds ++ circularAsds;
          })
          else master.overrideLispAttrs (o: {
            inherit lispLibs;
            inherit systems;
            asds = filter (x: !hasInfix "/" x) systems;
          });
      overrides = map combineSlashySubsystems duplicates;
      overriddenAsds = concatMap (getAttr "asds") overrides;
      replaceLib = lib:
        if !mutuallyExclusive lib.asds overriddenAsds
        # FIXME what if multiple overrides have conflicting asds?
        then
          findFirst
            (override: !mutuallyExclusive override.asds lib.asds)
            (throw "BUG! Missing override for ${toString lib.asds}")
            overrides
        else lib;
      lispLibs' = editTree libs (map replaceLib);
    in unique lispLibs';

  # The recent version of makeWrapper causes breakage. For more info see
  # https://github.com/Uthar/nix-cl/issues/2
  oldMakeWrapper = (import (builtins.fetchTarball {
    url = "https://github.com/nixos/nixpkgs/archive/37809af15e22cc4b1e3de3a9fad98b612881f6a5.tar.gz";
    sha256 = "0ay907qpvmzr3vhhc6bhwrwz6cdwiadbyxjqlq9wi4f2ldr1id59";
  }) {}).makeWrapper;

  # Creates a lisp wrapper with `packages` installed
  #
  # `packages` is a function that takes `clpkgs` - a set of lisp
  # packages - as argument and returns the list of packages to be
  # installed
  lispWithPackagesInternal = clpkgs: packages:
    # FIXME just use flattenedDeps instead
    (build-asdf-system rec {
      lisp = (head (lib.attrValues clpkgs)).lisp;
      # See dontUnpack in build-asdf-system
      src = null;
      pname = baseNameOf (head (split " " lisp));
      version = "with-packages";
      lispLibs = fixDuplicateAsds (packages clpkgs) clpkgs;
      nativeBuildInputs = [ oldMakeWrapper ];
      systems = [];
    }).overrideAttrs(o: {
      installPhase = ''
        mkdir -pv $out/bin
        makeWrapper \
          ${head (split " " o.lisp)} \
          $out/bin/${baseNameOf (head (split " " o.lisp))} \
          --prefix CL_SOURCE_REGISTRY : "${o.CL_SOURCE_REGISTRY}" \
          --prefix ASDF_OUTPUT_TRANSLATIONS : ${concatStringsSep "::" (flattenedDeps o.lispLibs)}: \
          --prefix LD_LIBRARY_PATH : "${o.LD_LIBRARY_PATH}" \
          --prefix LD_LIBRARY_PATH : "${makeLibraryPath o.nativeLibs}" \
          --prefix CLASSPATH : "${o.CLASSPATH}" \
          --prefix CLASSPATH : "${makeSearchPath "share/java/*" o.javaLibs}"
      '';
    });

  lispWithPackages = lisp:
    let
      packages = lispPackagesFor lisp;
    in lispWithPackagesInternal packages;

  lispPackagesFor = lisp:
    let
      packages = commonLispPackagesFor lisp;
      build-with-fix-duplicate-asds = args:
        head
          (fixDuplicateAsds
            [(build-asdf-system args)]
            (lispPackagesFor lisp));
      qlPackages = quicklispPackagesFor {
        inherit lisp;
        fixup = fixupFor packages;
        build = build-with-fix-duplicate-asds;
      };
    in qlPackages // packages;

  commonLispPackages = rec {
    inherit
      build-asdf-system
      lispWithPackagesInternal
      lispPackagesFor
      lispWithPackages;

    # There's got to be a better way than this...
    # The problem was that with --load everywhere, some
    # implementations didn't exit with 0 on compilation failure
    # Maybe a handler-case in buildScript?
    sbcl  = "${pkgs.sbcl}/bin/sbcl --script";
    ecl   = "${pkgs.ecl}/bin/ecl --shell";
    abcl  = ''${pkgs.abcl}/bin/abcl --batch --eval "(load \"$buildScript\")"'';
    ccl   = ''${pkgs.ccl}/bin/ccl --batch --eval "(load \"$buildScript\")" --'';
    clasp = ''${pkgs.clasp}/bin/clasp --non-interactive --quit --load'';

    # Manually defined packages shadow the ones imported from quicklisp

    sbclPackages  = lispPackagesFor sbcl;
    eclPackages   = lispPackagesFor ecl;
    abclPackages  = lispPackagesFor abcl;
    cclPackages   = lispPackagesFor ccl;
    claspPackages = lispPackagesFor clasp;

    sbclWithPackages  = lispWithPackages sbcl;
    eclWithPackages   = lispWithPackages ecl;
    abclWithPackages  = lispWithPackages abcl;
    cclWithPackages   = lispWithPackages ccl;
    claspWithPackages = lispWithPackages clasp;
  };

in commonLispPackages
